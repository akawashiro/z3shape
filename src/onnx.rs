// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `onnx.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  Attributes
///
///  A named attribute containing either singular float, integer, string, graph,
///  and tensor values, or repeated float, integer, string, graph, and tensor values.
///  An AttributeProto MUST contain the name field, and *only one* of the
///  following content fields, effectively enforcing a C/C++ union equivalent.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.AttributeProto)
pub struct AttributeProto {
    // message fields
    ///  The name field MUST be present for this version of the IR.
    // @@protoc_insertion_point(field:onnx.AttributeProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
    ///  In this case, this AttributeProto does not contain data, and it's a reference of attribute
    ///  in parent scope.
    ///  NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
    // @@protoc_insertion_point(field:onnx.AttributeProto.ref_attr_name)
    pub ref_attr_name: ::std::option::Option<::std::string::String>,
    ///  A human-readable documentation for this attribute. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.AttributeProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    ///  The type field MUST be present for this version of the IR.
    ///  For 0.0.1 versions of the IR, this field was not defined, and
    ///  implementations needed to use has_field heuristics to determine
    ///  which value field was in use.  For IR_VERSION 0.0.2 or later, this
    ///  field MUST be set and match the f|i|s|t|... field in use.  This
    ///  change was made to accommodate proto3 implementations.
    // @@protoc_insertion_point(field:onnx.AttributeProto.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<attribute_proto::AttributeType>>,
    ///  Exactly ONE of the following fields must be present for this version of the IR
    // @@protoc_insertion_point(field:onnx.AttributeProto.f)
    pub f: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.i)
    pub i: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.s)
    pub s: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.t)
    pub t: ::protobuf::MessageField<TensorProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.g)
    pub g: ::protobuf::MessageField<GraphProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.sparse_tensor)
    pub sparse_tensor: ::protobuf::MessageField<SparseTensorProto>,
    ///  Do not use field below, it's deprecated.
    ///  optional ValueProto v = 12;         // value - subsumes everything but graph
    // @@protoc_insertion_point(field:onnx.AttributeProto.tp)
    pub tp: ::protobuf::MessageField<TypeProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.floats)
    pub floats: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.ints)
    pub ints: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.strings)
    pub strings: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.tensors)
    pub tensors: ::std::vec::Vec<TensorProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.graphs)
    pub graphs: ::std::vec::Vec<GraphProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.sparse_tensors)
    pub sparse_tensors: ::std::vec::Vec<SparseTensorProto>,
    // @@protoc_insertion_point(field:onnx.AttributeProto.type_protos)
    pub type_protos: ::std::vec::Vec<TypeProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.AttributeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AttributeProto {
    fn default() -> &'a AttributeProto {
        <AttributeProto as ::protobuf::Message>::default_instance()
    }
}

impl AttributeProto {
    pub fn new() -> AttributeProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ref_attr_name = 21;

    pub fn ref_attr_name(&self) -> &str {
        match self.ref_attr_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ref_attr_name(&mut self) {
        self.ref_attr_name = ::std::option::Option::None;
    }

    pub fn has_ref_attr_name(&self) -> bool {
        self.ref_attr_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_attr_name(&mut self, v: ::std::string::String) {
        self.ref_attr_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_attr_name(&mut self) -> &mut ::std::string::String {
        if self.ref_attr_name.is_none() {
            self.ref_attr_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ref_attr_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_ref_attr_name(&mut self) -> ::std::string::String {
        self.ref_attr_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doc_string = 13;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .onnx.AttributeProto.AttributeType type = 20;

    pub fn type_(&self) -> attribute_proto::AttributeType {
        match self.type_ {
            Some(e) => e.enum_value_or(attribute_proto::AttributeType::UNDEFINED),
            None => attribute_proto::AttributeType::UNDEFINED,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: attribute_proto::AttributeType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float f = 2;

    pub fn f(&self) -> f32 {
        self.f.unwrap_or(0.)
    }

    pub fn clear_f(&mut self) {
        self.f = ::std::option::Option::None;
    }

    pub fn has_f(&self) -> bool {
        self.f.is_some()
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: f32) {
        self.f = ::std::option::Option::Some(v);
    }

    // optional int64 i = 3;

    pub fn i(&self) -> i64 {
        self.i.unwrap_or(0)
    }

    pub fn clear_i(&mut self) {
        self.i = ::std::option::Option::None;
    }

    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: i64) {
        self.i = ::std::option::Option::Some(v);
    }

    // optional bytes s = 4;

    pub fn s(&self) -> &[u8] {
        match self.s.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_s(&mut self) {
        self.s = ::std::option::Option::None;
    }

    pub fn has_s(&self) -> bool {
        self.s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::vec::Vec<u8>) {
        self.s = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.s.is_none() {
            self.s = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.s.as_mut().unwrap()
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::vec::Vec<u8> {
        self.s.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AttributeProto {
    const NAME: &'static str = "AttributeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.ref_attr_name = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.f = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.i = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.s = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.t)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.g)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_tensor)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tp)?;
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.floats)?;
                },
                61 => {
                    self.floats.push(is.read_float()?);
                },
                66 => {
                    is.read_repeated_packed_int64_into(&mut self.ints)?;
                },
                64 => {
                    self.ints.push(is.read_int64()?);
                },
                74 => {
                    self.strings.push(is.read_bytes()?);
                },
                82 => {
                    self.tensors.push(is.read_message()?);
                },
                90 => {
                    self.graphs.push(is.read_message()?);
                },
                186 => {
                    self.sparse_tensors.push(is.read_message()?);
                },
                122 => {
                    self.type_protos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ref_attr_name.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.f {
            my_size += 1 + 4;
        }
        if let Some(v) = self.i {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.s.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.g.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sparse_tensor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.floats.len() as u64;
        for value in &self.ints {
            my_size += ::protobuf::rt::int64_size(8, *value);
        };
        for value in &self.strings {
            my_size += ::protobuf::rt::bytes_size(9, &value);
        };
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.graphs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sparse_tensors {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.type_protos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ref_attr_name.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.f {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.i {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.s.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.t.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.g.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.sparse_tensor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.tp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.floats {
            os.write_float(7, *v)?;
        };
        for v in &self.ints {
            os.write_int64(8, *v)?;
        };
        for v in &self.strings {
            os.write_bytes(9, &v)?;
        };
        for v in &self.tensors {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.graphs {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.sparse_tensors {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        for v in &self.type_protos {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AttributeProto {
        AttributeProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.ref_attr_name = ::std::option::Option::None;
        self.doc_string = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.f = ::std::option::Option::None;
        self.i = ::std::option::Option::None;
        self.s = ::std::option::Option::None;
        self.t.clear();
        self.g.clear();
        self.sparse_tensor.clear();
        self.tp.clear();
        self.floats.clear();
        self.ints.clear();
        self.strings.clear();
        self.tensors.clear();
        self.graphs.clear();
        self.sparse_tensors.clear();
        self.type_protos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AttributeProto {
        static instance: AttributeProto = AttributeProto {
            name: ::std::option::Option::None,
            ref_attr_name: ::std::option::Option::None,
            doc_string: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            f: ::std::option::Option::None,
            i: ::std::option::Option::None,
            s: ::std::option::Option::None,
            t: ::protobuf::MessageField::none(),
            g: ::protobuf::MessageField::none(),
            sparse_tensor: ::protobuf::MessageField::none(),
            tp: ::protobuf::MessageField::none(),
            floats: ::std::vec::Vec::new(),
            ints: ::std::vec::Vec::new(),
            strings: ::std::vec::Vec::new(),
            tensors: ::std::vec::Vec::new(),
            graphs: ::std::vec::Vec::new(),
            sparse_tensors: ::std::vec::Vec::new(),
            type_protos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `AttributeProto`
pub mod attribute_proto {
    ///  Note: this enum is structurally identical to the OpSchema::AttrType
    ///  enum defined in schema.h.  If you rev one, you likely need to rev the other.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:onnx.AttributeProto.AttributeType)
    pub enum AttributeType {
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.UNDEFINED)
        UNDEFINED = 0,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.FLOAT)
        FLOAT = 1,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.INT)
        INT = 2,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.STRING)
        STRING = 3,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TENSOR)
        TENSOR = 4,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.GRAPH)
        GRAPH = 5,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.SPARSE_TENSOR)
        SPARSE_TENSOR = 11,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TYPE_PROTO)
        TYPE_PROTO = 13,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.FLOATS)
        FLOATS = 6,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.INTS)
        INTS = 7,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.STRINGS)
        STRINGS = 8,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TENSORS)
        TENSORS = 9,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.GRAPHS)
        GRAPHS = 10,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.SPARSE_TENSORS)
        SPARSE_TENSORS = 12,
        // @@protoc_insertion_point(enum_value:onnx.AttributeProto.AttributeType.TYPE_PROTOS)
        TYPE_PROTOS = 14,
    }

    impl ::protobuf::Enum for AttributeType {
        const NAME: &'static str = "AttributeType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AttributeType> {
            match value {
                0 => ::std::option::Option::Some(AttributeType::UNDEFINED),
                1 => ::std::option::Option::Some(AttributeType::FLOAT),
                2 => ::std::option::Option::Some(AttributeType::INT),
                3 => ::std::option::Option::Some(AttributeType::STRING),
                4 => ::std::option::Option::Some(AttributeType::TENSOR),
                5 => ::std::option::Option::Some(AttributeType::GRAPH),
                11 => ::std::option::Option::Some(AttributeType::SPARSE_TENSOR),
                13 => ::std::option::Option::Some(AttributeType::TYPE_PROTO),
                6 => ::std::option::Option::Some(AttributeType::FLOATS),
                7 => ::std::option::Option::Some(AttributeType::INTS),
                8 => ::std::option::Option::Some(AttributeType::STRINGS),
                9 => ::std::option::Option::Some(AttributeType::TENSORS),
                10 => ::std::option::Option::Some(AttributeType::GRAPHS),
                12 => ::std::option::Option::Some(AttributeType::SPARSE_TENSORS),
                14 => ::std::option::Option::Some(AttributeType::TYPE_PROTOS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AttributeType] = &[
            AttributeType::UNDEFINED,
            AttributeType::FLOAT,
            AttributeType::INT,
            AttributeType::STRING,
            AttributeType::TENSOR,
            AttributeType::GRAPH,
            AttributeType::SPARSE_TENSOR,
            AttributeType::TYPE_PROTO,
            AttributeType::FLOATS,
            AttributeType::INTS,
            AttributeType::STRINGS,
            AttributeType::TENSORS,
            AttributeType::GRAPHS,
            AttributeType::SPARSE_TENSORS,
            AttributeType::TYPE_PROTOS,
        ];
    }

    impl ::std::default::Default for AttributeType {
        fn default() -> Self {
            AttributeType::UNDEFINED
        }
    }

}

///  Defines information on value, including the name, the type, and
///  the shape of the value.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.ValueInfoProto)
pub struct ValueInfoProto {
    // message fields
    ///  This field MUST be present in this version of the IR.
    // @@protoc_insertion_point(field:onnx.ValueInfoProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  This field MUST be present in this version of the IR for
    ///  inputs and outputs of the top-level graph.
    // @@protoc_insertion_point(field:onnx.ValueInfoProto.type)
    pub type_: ::protobuf::MessageField<TypeProto>,
    ///  A human-readable documentation for this value. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.ValueInfoProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.ValueInfoProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValueInfoProto {
    fn default() -> &'a ValueInfoProto {
        <ValueInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ValueInfoProto {
    pub fn new() -> ValueInfoProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doc_string = 3;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ValueInfoProto {
    const NAME: &'static str = "ValueInfoProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                26 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValueInfoProto {
        ValueInfoProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.type_.clear();
        self.doc_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValueInfoProto {
        static instance: ValueInfoProto = ValueInfoProto {
            name: ::std::option::Option::None,
            type_: ::protobuf::MessageField::none(),
            doc_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Nodes
///
///  Computation graphs are made up of a DAG of nodes, which represent what is
///  commonly called a "layer" or "pipeline stage" in machine learning frameworks.
///
///  For example, it can be a node of type "Conv" that takes in an image, a filter
///  tensor and a bias tensor, and produces the convolved output.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.NodeProto)
pub struct NodeProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.NodeProto.input)
    pub input: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:onnx.NodeProto.output)
    pub output: ::std::vec::Vec<::std::string::String>,
    ///  An optional identifier for this node in a graph.
    ///  This field MAY be absent in ths version of the IR.
    // @@protoc_insertion_point(field:onnx.NodeProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  The symbolic identifier of the Operator to execute.
    // @@protoc_insertion_point(field:onnx.NodeProto.op_type)
    pub op_type: ::std::option::Option<::std::string::String>,
    ///  The domain of the OperatorSet that specifies the operator named by op_type.
    // @@protoc_insertion_point(field:onnx.NodeProto.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    ///  Additional named attributes.
    // @@protoc_insertion_point(field:onnx.NodeProto.attribute)
    pub attribute: ::std::vec::Vec<AttributeProto>,
    ///  A human-readable documentation for this node. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.NodeProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.NodeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NodeProto {
    fn default() -> &'a NodeProto {
        <NodeProto as ::protobuf::Message>::default_instance()
    }
}

impl NodeProto {
    pub fn new() -> NodeProto {
        ::std::default::Default::default()
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string op_type = 4;

    pub fn op_type(&self) -> &str {
        match self.op_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_op_type(&mut self) {
        self.op_type = ::std::option::Option::None;
    }

    pub fn has_op_type(&self) -> bool {
        self.op_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_type(&mut self, v: ::std::string::String) {
        self.op_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_type(&mut self) -> &mut ::std::string::String {
        if self.op_type.is_none() {
            self.op_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.op_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_type(&mut self) -> ::std::string::String {
        self.op_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 7;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doc_string = 6;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeProto {
    const NAME: &'static str = "NodeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.input.push(is.read_string()?);
                },
                18 => {
                    self.output.push(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.op_type = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.attribute.push(is.read_message()?);
                },
                50 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.op_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        for v in &self.output {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.op_type.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NodeProto {
        NodeProto::new()
    }

    fn clear(&mut self) {
        self.input.clear();
        self.output.clear();
        self.name = ::std::option::Option::None;
        self.op_type = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.attribute.clear();
        self.doc_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NodeProto {
        static instance: NodeProto = NodeProto {
            input: ::std::vec::Vec::new(),
            output: ::std::vec::Vec::new(),
            name: ::std::option::Option::None,
            op_type: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            doc_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Training information
///  TrainingInfoProto stores information for training a model.
///  In particular, this defines two functionalities: an initialization-step
///  and a training-algorithm-step. Initialization resets the model
///  back to its original state as if no training has been performed.
///  Training algorithm improves the model based on input data.
///
///  The semantics of the initialization-step is that the initializers
///  in ModelProto.graph and in TrainingInfoProto.algorithm are first
///  initialized as specified by the initializers in the graph, and then
///  updated by the "initialization_binding" in every instance in
///  ModelProto.training_info.
///
///  The field "algorithm" defines a computation graph which represents a
///  training algorithm's step. After the execution of a
///  TrainingInfoProto.algorithm, the initializers specified by "update_binding"
///  may be immediately updated. If the targeted training algorithm contains
///  consecutive update steps (such as block coordinate descent methods),
///  the user needs to create a TrainingInfoProto for each step.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.TrainingInfoProto)
pub struct TrainingInfoProto {
    // message fields
    ///  This field describes a graph to compute the initial tensors
    ///  upon starting the training process. Initialization graph has no input
    ///  and can have multiple outputs. Usually, trainable tensors in neural
    ///  networks are randomly initialized. To achieve that, for each tensor,
    ///  the user can put a random number operator such as RandomNormal or
    ///  RandomUniform in TrainingInfoProto.initialization.node and assign its
    ///  random output to the specific tensor using "initialization_binding".
    ///  This graph can also set the initializers in "algorithm" in the same
    ///  TrainingInfoProto; a use case is resetting the number of training
    ///  iteration to zero.
    ///
    ///  By default, this field is an empty graph and its evaluation does not
    ///  produce any output. Thus, no initializer would be changed by default.
    // @@protoc_insertion_point(field:onnx.TrainingInfoProto.initialization)
    pub initialization: ::protobuf::MessageField<GraphProto>,
    // @@protoc_insertion_point(field:onnx.TrainingInfoProto.algorithm)
    pub algorithm: ::protobuf::MessageField<GraphProto>,
    ///  This field specifies the bindings from the outputs of "initialization" to
    ///  some initializers in "ModelProto.graph.initializer" and
    ///  the "algorithm.initializer" in the same TrainingInfoProto.
    ///  See "update_binding" below for details.
    ///
    ///  By default, this field is empty and no initializer would be changed
    ///  by the execution of "initialization".
    // @@protoc_insertion_point(field:onnx.TrainingInfoProto.initialization_binding)
    pub initialization_binding: ::std::vec::Vec<StringStringEntryProto>,
    // @@protoc_insertion_point(field:onnx.TrainingInfoProto.update_binding)
    pub update_binding: ::std::vec::Vec<StringStringEntryProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TrainingInfoProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrainingInfoProto {
    fn default() -> &'a TrainingInfoProto {
        <TrainingInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl TrainingInfoProto {
    pub fn new() -> TrainingInfoProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TrainingInfoProto {
    const NAME: &'static str = "TrainingInfoProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.initialization)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.algorithm)?;
                },
                26 => {
                    self.initialization_binding.push(is.read_message()?);
                },
                34 => {
                    self.update_binding.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initialization.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.algorithm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.initialization_binding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.update_binding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initialization.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.algorithm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.initialization_binding {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.update_binding {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrainingInfoProto {
        TrainingInfoProto::new()
    }

    fn clear(&mut self) {
        self.initialization.clear();
        self.algorithm.clear();
        self.initialization_binding.clear();
        self.update_binding.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrainingInfoProto {
        static instance: TrainingInfoProto = TrainingInfoProto {
            initialization: ::protobuf::MessageField::none(),
            algorithm: ::protobuf::MessageField::none(),
            initialization_binding: ::std::vec::Vec::new(),
            update_binding: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Models
///
///  ModelProto is a top-level file/container format for bundling a ML model and
///  associating its computation graph with metadata.
///
///  The semantics of the model are described by the associated GraphProto's.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.ModelProto)
pub struct ModelProto {
    // message fields
    ///  The version of the IR this model targets. See Version enum above.
    ///  This field MUST be present.
    // @@protoc_insertion_point(field:onnx.ModelProto.ir_version)
    pub ir_version: ::std::option::Option<i64>,
    ///  The OperatorSets this model relies on.
    ///  All ModelProtos MUST have at least one entry that
    ///  specifies which version of the ONNX OperatorSet is
    ///  being imported.
    ///
    ///  All nodes in the ModelProto's graph will bind against the operator
    ///  with the same-domain/same-op_type operator with the HIGHEST version
    ///  in the referenced operator sets.
    // @@protoc_insertion_point(field:onnx.ModelProto.opset_import)
    pub opset_import: ::std::vec::Vec<OperatorSetIdProto>,
    ///  The name of the framework or tool used to generate this model.
    ///  This field SHOULD be present to indicate which implementation/tool/framework
    ///  emitted the model.
    // @@protoc_insertion_point(field:onnx.ModelProto.producer_name)
    pub producer_name: ::std::option::Option<::std::string::String>,
    ///  The version of the framework or tool used to generate this model.
    ///  This field SHOULD be present to indicate which implementation/tool/framework
    ///  emitted the model.
    // @@protoc_insertion_point(field:onnx.ModelProto.producer_version)
    pub producer_version: ::std::option::Option<::std::string::String>,
    ///  Domain name of the model.
    ///  We use reverse domain names as name space indicators. For example:
    ///  `com.facebook.fair` or `com.microsoft.cognitiveservices`
    ///
    ///  Together with `model_version` and GraphProto.name, this forms the unique identity of
    ///  the graph.
    // @@protoc_insertion_point(field:onnx.ModelProto.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    ///  The version of the graph encoded. See Version enum below.
    // @@protoc_insertion_point(field:onnx.ModelProto.model_version)
    pub model_version: ::std::option::Option<i64>,
    ///  A human-readable documentation for this model. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.ModelProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    ///  The parameterized graph that is evaluated to execute the model.
    // @@protoc_insertion_point(field:onnx.ModelProto.graph)
    pub graph: ::protobuf::MessageField<GraphProto>,
    ///  Named metadata values; keys should be distinct.
    // @@protoc_insertion_point(field:onnx.ModelProto.metadata_props)
    pub metadata_props: ::std::vec::Vec<StringStringEntryProto>,
    ///  Training-specific information. Sequentially executing all stored
    ///  `TrainingInfoProto.algorithm`s and assigning their outputs following
    ///  the corresponding `TrainingInfoProto.update_binding`s is one training
    ///  iteration. Similarly, to initialize the model
    ///  (as if training hasn't happened), the user should sequentially execute
    ///  all stored `TrainingInfoProto.initialization`s and assigns their outputs
    ///  using `TrainingInfoProto.initialization_binding`s.
    ///
    ///  If this field is empty, the training behavior of the model is undefined.
    // @@protoc_insertion_point(field:onnx.ModelProto.training_info)
    pub training_info: ::std::vec::Vec<TrainingInfoProto>,
    ///  A list of function protos local to the model.
    ///
    ///  Name of the function "FunctionProto.name" should be unique within the domain "FunctionProto.domain".
    ///  In case of any conflicts the behavior (whether the model local functions are given higher priority,
    ///  or standard opserator sets are given higher priotity or this is treated as error) is defined by
    ///  the runtimes.
    ///
    ///  The operator sets imported by FunctionProto should be compatible with the ones
    ///  imported by ModelProto and other model local FunctionProtos.
    ///  Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
    ///  or by 2 FunctionProtos then versions for the operator set may be different but,
    ///  the operator schema returned for op_type, domain, version combination
    ///  for both the versions should be same for every node in the function body.
    ///
    ///  One FunctionProto can reference other FunctionProto in the model, however, recursive reference
    ///  is not allowed.
    // @@protoc_insertion_point(field:onnx.ModelProto.functions)
    pub functions: ::std::vec::Vec<FunctionProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.ModelProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelProto {
    fn default() -> &'a ModelProto {
        <ModelProto as ::protobuf::Message>::default_instance()
    }
}

impl ModelProto {
    pub fn new() -> ModelProto {
        ::std::default::Default::default()
    }

    // optional int64 ir_version = 1;

    pub fn ir_version(&self) -> i64 {
        self.ir_version.unwrap_or(0)
    }

    pub fn clear_ir_version(&mut self) {
        self.ir_version = ::std::option::Option::None;
    }

    pub fn has_ir_version(&self) -> bool {
        self.ir_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ir_version(&mut self, v: i64) {
        self.ir_version = ::std::option::Option::Some(v);
    }

    // optional string producer_name = 2;

    pub fn producer_name(&self) -> &str {
        match self.producer_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_producer_name(&mut self) {
        self.producer_name = ::std::option::Option::None;
    }

    pub fn has_producer_name(&self) -> bool {
        self.producer_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_name(&mut self, v: ::std::string::String) {
        self.producer_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_name(&mut self) -> &mut ::std::string::String {
        if self.producer_name.is_none() {
            self.producer_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.producer_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_name(&mut self) -> ::std::string::String {
        self.producer_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string producer_version = 3;

    pub fn producer_version(&self) -> &str {
        match self.producer_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_producer_version(&mut self) {
        self.producer_version = ::std::option::Option::None;
    }

    pub fn has_producer_version(&self) -> bool {
        self.producer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_producer_version(&mut self, v: ::std::string::String) {
        self.producer_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer_version(&mut self) -> &mut ::std::string::String {
        if self.producer_version.is_none() {
            self.producer_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.producer_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_producer_version(&mut self) -> ::std::string::String {
        self.producer_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 4;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 model_version = 5;

    pub fn model_version(&self) -> i64 {
        self.model_version.unwrap_or(0)
    }

    pub fn clear_model_version(&mut self) {
        self.model_version = ::std::option::Option::None;
    }

    pub fn has_model_version(&self) -> bool {
        self.model_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_version(&mut self, v: i64) {
        self.model_version = ::std::option::Option::Some(v);
    }

    // optional string doc_string = 6;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModelProto {
    const NAME: &'static str = "ModelProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ir_version = ::std::option::Option::Some(is.read_int64()?);
                },
                66 => {
                    self.opset_import.push(is.read_message()?);
                },
                18 => {
                    self.producer_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.producer_version = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.model_version = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.graph)?;
                },
                114 => {
                    self.metadata_props.push(is.read_message()?);
                },
                162 => {
                    self.training_info.push(is.read_message()?);
                },
                202 => {
                    self.functions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ir_version {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        for value in &self.opset_import {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.producer_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.producer_version.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.model_version {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metadata_props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.training_info {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.functions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ir_version {
            os.write_int64(1, v)?;
        }
        for v in &self.opset_import {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.producer_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.producer_version.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.domain.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.model_version {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.graph.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.metadata_props {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        for v in &self.training_info {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.functions {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelProto {
        ModelProto::new()
    }

    fn clear(&mut self) {
        self.ir_version = ::std::option::Option::None;
        self.opset_import.clear();
        self.producer_name = ::std::option::Option::None;
        self.producer_version = ::std::option::Option::None;
        self.domain = ::std::option::Option::None;
        self.model_version = ::std::option::Option::None;
        self.doc_string = ::std::option::Option::None;
        self.graph.clear();
        self.metadata_props.clear();
        self.training_info.clear();
        self.functions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelProto {
        static instance: ModelProto = ModelProto {
            ir_version: ::std::option::Option::None,
            opset_import: ::std::vec::Vec::new(),
            producer_name: ::std::option::Option::None,
            producer_version: ::std::option::Option::None,
            domain: ::std::option::Option::None,
            model_version: ::std::option::Option::None,
            doc_string: ::std::option::Option::None,
            graph: ::protobuf::MessageField::none(),
            metadata_props: ::std::vec::Vec::new(),
            training_info: ::std::vec::Vec::new(),
            functions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  StringStringEntryProto follows the pattern for cross-proto-version maps.
///  See https://developers.google.com/protocol-buffers/docs/proto3#maps
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.StringStringEntryProto)
pub struct StringStringEntryProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.StringStringEntryProto.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:onnx.StringStringEntryProto.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.StringStringEntryProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringStringEntryProto {
    fn default() -> &'a StringStringEntryProto {
        <StringStringEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl StringStringEntryProto {
    pub fn new() -> StringStringEntryProto {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StringStringEntryProto {
    const NAME: &'static str = "StringStringEntryProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringStringEntryProto {
        StringStringEntryProto::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringStringEntryProto {
        static instance: StringStringEntryProto = StringStringEntryProto {
            key: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.TensorAnnotation)
pub struct TensorAnnotation {
    // message fields
    // @@protoc_insertion_point(field:onnx.TensorAnnotation.tensor_name)
    pub tensor_name: ::std::option::Option<::std::string::String>,
    ///  <key, value> pairs to annotate tensor specified by <tensor_name> above.
    ///  The keys used in the mapping below must be pre-defined in ONNX spec.
    ///  For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
    ///  quantization parameter keys.
    // @@protoc_insertion_point(field:onnx.TensorAnnotation.quant_parameter_tensor_names)
    pub quant_parameter_tensor_names: ::std::vec::Vec<StringStringEntryProto>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorAnnotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TensorAnnotation {
    fn default() -> &'a TensorAnnotation {
        <TensorAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl TensorAnnotation {
    pub fn new() -> TensorAnnotation {
        ::std::default::Default::default()
    }

    // optional string tensor_name = 1;

    pub fn tensor_name(&self) -> &str {
        match self.tensor_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tensor_name(&mut self) {
        self.tensor_name = ::std::option::Option::None;
    }

    pub fn has_tensor_name(&self) -> bool {
        self.tensor_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tensor_name(&mut self, v: ::std::string::String) {
        self.tensor_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tensor_name(&mut self) -> &mut ::std::string::String {
        if self.tensor_name.is_none() {
            self.tensor_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tensor_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_tensor_name(&mut self) -> ::std::string::String {
        self.tensor_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TensorAnnotation {
    const NAME: &'static str = "TensorAnnotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tensor_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.quant_parameter_tensor_names.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tensor_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.quant_parameter_tensor_names {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tensor_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.quant_parameter_tensor_names {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TensorAnnotation {
        TensorAnnotation::new()
    }

    fn clear(&mut self) {
        self.tensor_name = ::std::option::Option::None;
        self.quant_parameter_tensor_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TensorAnnotation {
        static instance: TensorAnnotation = TensorAnnotation {
            tensor_name: ::std::option::Option::None,
            quant_parameter_tensor_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Graphs
///
///  A graph defines the computational logic of a model and is comprised of a parameterized
///  list of nodes that form a directed acyclic graph based on their inputs and outputs.
///  This is the equivalent of the "network" or "graph" in many deep learning
///  frameworks.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.GraphProto)
pub struct GraphProto {
    // message fields
    ///  The nodes in the graph, sorted topologically.
    // @@protoc_insertion_point(field:onnx.GraphProto.node)
    pub node: ::std::vec::Vec<NodeProto>,
    ///  The name of the graph.
    // @@protoc_insertion_point(field:onnx.GraphProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  A list of named tensor values, used to specify constant inputs of the graph.
    ///  Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
    ///  The name MUST be unique across both initializer and sparse_initializer,
    ///  but the name MAY also appear in the input list.
    // @@protoc_insertion_point(field:onnx.GraphProto.initializer)
    pub initializer: ::std::vec::Vec<TensorProto>,
    ///  Initializers (see above) stored in sparse format.
    // @@protoc_insertion_point(field:onnx.GraphProto.sparse_initializer)
    pub sparse_initializer: ::std::vec::Vec<SparseTensorProto>,
    ///  A human-readable documentation for this graph. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.GraphProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    ///  The inputs and outputs of the graph.
    // @@protoc_insertion_point(field:onnx.GraphProto.input)
    pub input: ::std::vec::Vec<ValueInfoProto>,
    // @@protoc_insertion_point(field:onnx.GraphProto.output)
    pub output: ::std::vec::Vec<ValueInfoProto>,
    ///  Information for the values in the graph. The ValueInfoProto.name's
    ///  must be distinct. It is optional for a value to appear in value_info list.
    // @@protoc_insertion_point(field:onnx.GraphProto.value_info)
    pub value_info: ::std::vec::Vec<ValueInfoProto>,
    ///  This field carries information to indicate the mapping among a tensor and its
    ///  quantization parameter tensors. For example:
    ///  For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
    ///  which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
    // @@protoc_insertion_point(field:onnx.GraphProto.quantization_annotation)
    pub quantization_annotation: ::std::vec::Vec<TensorAnnotation>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.GraphProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GraphProto {
    fn default() -> &'a GraphProto {
        <GraphProto as ::protobuf::Message>::default_instance()
    }
}

impl GraphProto {
    pub fn new() -> GraphProto {
        ::std::default::Default::default()
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doc_string = 10;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GraphProto {
    const NAME: &'static str = "GraphProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.node.push(is.read_message()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.initializer.push(is.read_message()?);
                },
                122 => {
                    self.sparse_initializer.push(is.read_message()?);
                },
                82 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.input.push(is.read_message()?);
                },
                98 => {
                    self.output.push(is.read_message()?);
                },
                106 => {
                    self.value_info.push(is.read_message()?);
                },
                114 => {
                    self.quantization_annotation.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.initializer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.sparse_initializer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.value_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.quantization_annotation {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.node {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.initializer {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.sparse_initializer {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.input {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.output {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.value_info {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.quantization_annotation {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GraphProto {
        GraphProto::new()
    }

    fn clear(&mut self) {
        self.node.clear();
        self.name = ::std::option::Option::None;
        self.initializer.clear();
        self.sparse_initializer.clear();
        self.doc_string = ::std::option::Option::None;
        self.input.clear();
        self.output.clear();
        self.value_info.clear();
        self.quantization_annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GraphProto {
        static instance: GraphProto = GraphProto {
            node: ::std::vec::Vec::new(),
            name: ::std::option::Option::None,
            initializer: ::std::vec::Vec::new(),
            sparse_initializer: ::std::vec::Vec::new(),
            doc_string: ::std::option::Option::None,
            input: ::std::vec::Vec::new(),
            output: ::std::vec::Vec::new(),
            value_info: ::std::vec::Vec::new(),
            quantization_annotation: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Tensors
///
///  A serialized tensor value.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.TensorProto)
pub struct TensorProto {
    // message fields
    ///  The shape of the tensor.
    // @@protoc_insertion_point(field:onnx.TensorProto.dims)
    pub dims: ::std::vec::Vec<i64>,
    ///  The data type of the tensor.
    ///  This field MUST have a valid TensorProto.DataType value
    // @@protoc_insertion_point(field:onnx.TensorProto.data_type)
    pub data_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:onnx.TensorProto.segment)
    pub segment: ::protobuf::MessageField<tensor_proto::Segment>,
    ///  For float and complex64 values
    ///  Complex64 tensors are encoded as a single array of floats,
    ///  with the real components appearing in odd numbered positions,
    ///  and the corresponding imaginary component appearing in the
    ///  subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
    ///  is encoded as [1.0, 2.0 ,3.0 ,4.0]
    ///  When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
    // @@protoc_insertion_point(field:onnx.TensorProto.float_data)
    pub float_data: ::std::vec::Vec<f32>,
    ///  For int32, uint8, int8, uint16, int16, bool, and float16 values
    ///  float16 values must be bit-wise converted to an uint16_t prior
    ///  to writing to the buffer.
    ///  When this field is present, the data_type field MUST be
    ///  INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
    // @@protoc_insertion_point(field:onnx.TensorProto.int32_data)
    pub int32_data: ::std::vec::Vec<i32>,
    ///  For strings.
    ///  Each element of string_data is a UTF-8 encoded Unicode
    ///  string. No trailing null, no leading BOM. The protobuf "string"
    ///  scalar type is not used to match ML community conventions.
    ///  When this field is present, the data_type field MUST be STRING
    // @@protoc_insertion_point(field:onnx.TensorProto.string_data)
    pub string_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
    ///  For int64.
    ///  When this field is present, the data_type field MUST be INT64
    // @@protoc_insertion_point(field:onnx.TensorProto.int64_data)
    pub int64_data: ::std::vec::Vec<i64>,
    ///  Optionally, a name for the tensor.
    // @@protoc_insertion_point(field:onnx.TensorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  A human-readable documentation for this tensor. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.TensorProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    ///  Serializations can either use one of the fields above, or use this
    ///  raw bytes field. The only exception is the string case, where one is
    ///  required to store the content in the repeated bytes string_data field.
    ///
    ///  When this raw_data field is used to store tensor value, elements MUST
    ///  be stored in as fixed-width, little-endian order.
    ///  Floating-point data types MUST be stored in IEEE 754 format.
    ///  Complex64 elements must be written as two consecutive FLOAT values, real component first.
    ///  Complex128 elements must be written as two consecutive DOUBLE values, real component first.
    ///  Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
    ///
    ///  Note: the advantage of specific field rather than the raw_data field is
    ///  that in some cases (e.g. int data), protobuf does a better packing via
    ///  variable length storage, and may lead to smaller binary footprint.
    ///  When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
    // @@protoc_insertion_point(field:onnx.TensorProto.raw_data)
    pub raw_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:onnx.TensorProto.external_data)
    pub external_data: ::std::vec::Vec<StringStringEntryProto>,
    ///  If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
    // @@protoc_insertion_point(field:onnx.TensorProto.data_location)
    pub data_location: ::std::option::Option<::protobuf::EnumOrUnknown<tensor_proto::DataLocation>>,
    ///  For double
    ///  Complex128 tensors are encoded as a single array of doubles,
    ///  with the real components appearing in odd numbered positions,
    ///  and the corresponding imaginary component appearing in the
    ///  subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
    ///  is encoded as [1.0, 2.0 ,3.0 ,4.0]
    ///  When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
    // @@protoc_insertion_point(field:onnx.TensorProto.double_data)
    pub double_data: ::std::vec::Vec<f64>,
    ///  For uint64 and uint32 values
    ///  When this field is present, the data_type field MUST be
    ///  UINT32 or UINT64
    // @@protoc_insertion_point(field:onnx.TensorProto.uint64_data)
    pub uint64_data: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TensorProto {
    fn default() -> &'a TensorProto {
        <TensorProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorProto {
    pub fn new() -> TensorProto {
        ::std::default::Default::default()
    }

    // optional int32 data_type = 2;

    pub fn data_type(&self) -> i32 {
        self.data_type.unwrap_or(0)
    }

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: i32) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // optional string name = 8;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doc_string = 12;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes raw_data = 9;

    pub fn raw_data(&self) -> &[u8] {
        match self.raw_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_raw_data(&mut self) {
        self.raw_data = ::std::option::Option::None;
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_data.is_none() {
            self.raw_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .onnx.TensorProto.DataLocation data_location = 14;

    pub fn data_location(&self) -> tensor_proto::DataLocation {
        match self.data_location {
            Some(e) => e.enum_value_or(tensor_proto::DataLocation::DEFAULT),
            None => tensor_proto::DataLocation::DEFAULT,
        }
    }

    pub fn clear_data_location(&mut self) {
        self.data_location = ::std::option::Option::None;
    }

    pub fn has_data_location(&self) -> bool {
        self.data_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_location(&mut self, v: tensor_proto::DataLocation) {
        self.data_location = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::protobuf::Message for TensorProto {
    const NAME: &'static str = "TensorProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int64_into(&mut self.dims)?;
                },
                8 => {
                    self.dims.push(is.read_int64()?);
                },
                16 => {
                    self.data_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.segment)?;
                },
                34 => {
                    is.read_repeated_packed_float_into(&mut self.float_data)?;
                },
                37 => {
                    self.float_data.push(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.int32_data)?;
                },
                40 => {
                    self.int32_data.push(is.read_int32()?);
                },
                50 => {
                    self.string_data.push(is.read_bytes()?);
                },
                58 => {
                    is.read_repeated_packed_int64_into(&mut self.int64_data)?;
                },
                56 => {
                    self.int64_data.push(is.read_int64()?);
                },
                66 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.raw_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                106 => {
                    self.external_data.push(is.read_message()?);
                },
                112 => {
                    self.data_location = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    is.read_repeated_packed_double_into(&mut self.double_data)?;
                },
                81 => {
                    self.double_data.push(is.read_double()?);
                },
                90 => {
                    is.read_repeated_packed_uint64_into(&mut self.uint64_data)?;
                },
                88 => {
                    self.uint64_data.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::int64_size(1, *value);
        };
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.segment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_float_size(4, &self.float_data);
        my_size += ::protobuf::rt::vec_packed_int32_size(5, &self.int32_data);
        for value in &self.string_data {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        my_size += ::protobuf::rt::vec_packed_int64_size(7, &self.int64_data);
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.raw_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        for value in &self.external_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.data_location {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        my_size += ::protobuf::rt::vec_packed_double_size(10, &self.double_data);
        my_size += ::protobuf::rt::vec_packed_uint64_size(11, &self.uint64_data);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if let Some(v) = self.data_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.segment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_repeated_packed_float(4, &self.float_data)?;
        os.write_repeated_packed_int32(5, &self.int32_data)?;
        for v in &self.string_data {
            os.write_bytes(6, &v)?;
        };
        os.write_repeated_packed_int64(7, &self.int64_data)?;
        if let Some(v) = self.name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.raw_data.as_ref() {
            os.write_bytes(9, v)?;
        }
        for v in &self.external_data {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.data_location {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_repeated_packed_double(10, &self.double_data)?;
        os.write_repeated_packed_uint64(11, &self.uint64_data)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TensorProto {
        TensorProto::new()
    }

    fn clear(&mut self) {
        self.dims.clear();
        self.data_type = ::std::option::Option::None;
        self.segment.clear();
        self.float_data.clear();
        self.int32_data.clear();
        self.string_data.clear();
        self.int64_data.clear();
        self.name = ::std::option::Option::None;
        self.doc_string = ::std::option::Option::None;
        self.raw_data = ::std::option::Option::None;
        self.external_data.clear();
        self.data_location = ::std::option::Option::None;
        self.double_data.clear();
        self.uint64_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TensorProto {
        static instance: TensorProto = TensorProto {
            dims: ::std::vec::Vec::new(),
            data_type: ::std::option::Option::None,
            segment: ::protobuf::MessageField::none(),
            float_data: ::std::vec::Vec::new(),
            int32_data: ::std::vec::Vec::new(),
            string_data: ::std::vec::Vec::new(),
            int64_data: ::std::vec::Vec::new(),
            name: ::std::option::Option::None,
            doc_string: ::std::option::Option::None,
            raw_data: ::std::option::Option::None,
            external_data: ::std::vec::Vec::new(),
            data_location: ::std::option::Option::None,
            double_data: ::std::vec::Vec::new(),
            uint64_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `TensorProto`
pub mod tensor_proto {
    ///  For very large tensors, we may want to store them in chunks, in which
    ///  case the following fields will specify the segment that is stored in
    ///  the current TensorProto.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TensorProto.Segment)
    pub struct Segment {
        // message fields
        // @@protoc_insertion_point(field:onnx.TensorProto.Segment.begin)
        pub begin: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:onnx.TensorProto.Segment.end)
        pub end: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TensorProto.Segment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Segment {
        fn default() -> &'a Segment {
            <Segment as ::protobuf::Message>::default_instance()
        }
    }

    impl Segment {
        pub fn new() -> Segment {
            ::std::default::Default::default()
        }

        // optional int64 begin = 1;

        pub fn begin(&self) -> i64 {
            self.begin.unwrap_or(0)
        }

        pub fn clear_begin(&mut self) {
            self.begin = ::std::option::Option::None;
        }

        pub fn has_begin(&self) -> bool {
            self.begin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_begin(&mut self, v: i64) {
            self.begin = ::std::option::Option::Some(v);
        }

        // optional int64 end = 2;

        pub fn end(&self) -> i64 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i64) {
            self.end = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Segment {
        const NAME: &'static str = "Segment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.begin = ::std::option::Option::Some(is.read_int64()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.begin {
                my_size += ::protobuf::rt::int64_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.begin {
                os.write_int64(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Segment {
            Segment::new()
        }

        fn clear(&mut self) {
            self.begin = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Segment {
            static instance: Segment = Segment {
                begin: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:onnx.TensorProto.DataType)
    pub enum DataType {
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UNDEFINED)
        UNDEFINED = 0,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT)
        FLOAT = 1,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT8)
        UINT8 = 2,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT8)
        INT8 = 3,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT16)
        UINT16 = 4,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT16)
        INT16 = 5,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT32)
        INT32 = 6,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.INT64)
        INT64 = 7,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.STRING)
        STRING = 8,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.BOOL)
        BOOL = 9,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.FLOAT16)
        FLOAT16 = 10,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.DOUBLE)
        DOUBLE = 11,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT32)
        UINT32 = 12,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.UINT64)
        UINT64 = 13,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.COMPLEX64)
        COMPLEX64 = 14,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.COMPLEX128)
        COMPLEX128 = 15,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataType.BFLOAT16)
        BFLOAT16 = 16,
    }

    impl ::protobuf::Enum for DataType {
        const NAME: &'static str = "DataType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DataType> {
            match value {
                0 => ::std::option::Option::Some(DataType::UNDEFINED),
                1 => ::std::option::Option::Some(DataType::FLOAT),
                2 => ::std::option::Option::Some(DataType::UINT8),
                3 => ::std::option::Option::Some(DataType::INT8),
                4 => ::std::option::Option::Some(DataType::UINT16),
                5 => ::std::option::Option::Some(DataType::INT16),
                6 => ::std::option::Option::Some(DataType::INT32),
                7 => ::std::option::Option::Some(DataType::INT64),
                8 => ::std::option::Option::Some(DataType::STRING),
                9 => ::std::option::Option::Some(DataType::BOOL),
                10 => ::std::option::Option::Some(DataType::FLOAT16),
                11 => ::std::option::Option::Some(DataType::DOUBLE),
                12 => ::std::option::Option::Some(DataType::UINT32),
                13 => ::std::option::Option::Some(DataType::UINT64),
                14 => ::std::option::Option::Some(DataType::COMPLEX64),
                15 => ::std::option::Option::Some(DataType::COMPLEX128),
                16 => ::std::option::Option::Some(DataType::BFLOAT16),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DataType] = &[
            DataType::UNDEFINED,
            DataType::FLOAT,
            DataType::UINT8,
            DataType::INT8,
            DataType::UINT16,
            DataType::INT16,
            DataType::INT32,
            DataType::INT64,
            DataType::STRING,
            DataType::BOOL,
            DataType::FLOAT16,
            DataType::DOUBLE,
            DataType::UINT32,
            DataType::UINT64,
            DataType::COMPLEX64,
            DataType::COMPLEX128,
            DataType::BFLOAT16,
        ];
    }

    impl ::std::default::Default for DataType {
        fn default() -> Self {
            DataType::UNDEFINED
        }
    }


    ///  Location of the data for this tensor. MUST be one of:
    ///  - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
    ///  - EXTERNAL - data stored in an external location as described by external_data field.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:onnx.TensorProto.DataLocation)
    pub enum DataLocation {
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataLocation.DEFAULT)
        DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:onnx.TensorProto.DataLocation.EXTERNAL)
        EXTERNAL = 1,
    }

    impl ::protobuf::Enum for DataLocation {
        const NAME: &'static str = "DataLocation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DataLocation> {
            match value {
                0 => ::std::option::Option::Some(DataLocation::DEFAULT),
                1 => ::std::option::Option::Some(DataLocation::EXTERNAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DataLocation] = &[
            DataLocation::DEFAULT,
            DataLocation::EXTERNAL,
        ];
    }

    impl ::std::default::Default for DataLocation {
        fn default() -> Self {
            DataLocation::DEFAULT
        }
    }

}

///  A serialized sparse-tensor value
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.SparseTensorProto)
pub struct SparseTensorProto {
    // message fields
    ///  The sequence of non-default values are encoded as a tensor of shape [NNZ].
    ///  The default-value is zero for numeric tensors, and empty-string for string tensors.
    ///  values must have a non-empty name present which serves as a name for SparseTensorProto
    ///  when used in sparse_initializer list.
    // @@protoc_insertion_point(field:onnx.SparseTensorProto.values)
    pub values: ::protobuf::MessageField<TensorProto>,
    ///  The indices of the non-default values, which may be stored in one of two formats.
    ///  (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
    ///  corresponding to the j-th index of the i-th value (in the values tensor).
    ///  (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
    ///  must be the linearized-index of the i-th value (in the values tensor).
    ///  The linearized-index can be converted into an index tuple (k_1,...,k_rank)
    ///  using the shape provided below.
    ///  The indices must appear in ascending order without duplication.
    ///  In the first format, the ordering is lexicographic-ordering:
    ///  e.g., index-value [1,4] must appear before [2,1]
    // @@protoc_insertion_point(field:onnx.SparseTensorProto.indices)
    pub indices: ::protobuf::MessageField<TensorProto>,
    ///  The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
    // @@protoc_insertion_point(field:onnx.SparseTensorProto.dims)
    pub dims: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.SparseTensorProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SparseTensorProto {
    fn default() -> &'a SparseTensorProto {
        <SparseTensorProto as ::protobuf::Message>::default_instance()
    }
}

impl SparseTensorProto {
    pub fn new() -> SparseTensorProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SparseTensorProto {
    const NAME: &'static str = "SparseTensorProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.values)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.indices)?;
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.dims)?;
                },
                24 => {
                    self.dims.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.indices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.dims {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.indices.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.dims {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SparseTensorProto {
        SparseTensorProto::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.indices.clear();
        self.dims.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SparseTensorProto {
        static instance: SparseTensorProto = SparseTensorProto {
            values: ::protobuf::MessageField::none(),
            indices: ::protobuf::MessageField::none(),
            dims: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Defines a tensor shape. A dimension can be either an integer value
///  or a symbolic variable. A symbolic variable represents an unknown
///  dimension.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.TensorShapeProto)
pub struct TensorShapeProto {
    // message fields
    // @@protoc_insertion_point(field:onnx.TensorShapeProto.dim)
    pub dim: ::std::vec::Vec<tensor_shape_proto::Dimension>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TensorShapeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TensorShapeProto {
    fn default() -> &'a TensorShapeProto {
        <TensorShapeProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorShapeProto {
    pub fn new() -> TensorShapeProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TensorShapeProto {
    const NAME: &'static str = "TensorShapeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dim.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dim {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dim {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TensorShapeProto {
        TensorShapeProto::new()
    }

    fn clear(&mut self) {
        self.dim.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TensorShapeProto {
        static instance: TensorShapeProto = TensorShapeProto {
            dim: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `TensorShapeProto`
pub mod tensor_shape_proto {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TensorShapeProto.Dimension)
    pub struct Dimension {
        // message fields
        ///  Standard denotation can optionally be used to denote tensor
        ///  dimensions with standard semantic descriptions to ensure
        ///  that operations are applied to the correct axis of a tensor.
        ///  Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
        ///  for pre-defined dimension denotations.
        // @@protoc_insertion_point(field:onnx.TensorShapeProto.Dimension.denotation)
        pub denotation: ::std::option::Option<::std::string::String>,
        // message oneof groups
        pub value: ::std::option::Option<dimension::Value>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TensorShapeProto.Dimension.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Dimension {
        fn default() -> &'a Dimension {
            <Dimension as ::protobuf::Message>::default_instance()
        }
    }

    impl Dimension {
        pub fn new() -> Dimension {
            ::std::default::Default::default()
        }

        // optional int64 dim_value = 1;

        pub fn dim_value(&self) -> i64 {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimValue(v)) => v,
                _ => 0,
            }
        }

        pub fn clear_dim_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_dim_value(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimValue(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_dim_value(&mut self, v: i64) {
            self.value = ::std::option::Option::Some(dimension::Value::DimValue(v))
        }

        // optional string dim_param = 2;

        pub fn dim_param(&self) -> &str {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimParam(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_dim_param(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_dim_param(&self) -> bool {
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimParam(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_dim_param(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(dimension::Value::DimParam(v))
        }

        // Mutable pointer to the field.
        pub fn mut_dim_param(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(dimension::Value::DimParam(_)) = self.value {
            } else {
                self.value = ::std::option::Option::Some(dimension::Value::DimParam(::std::string::String::new()));
            }
            match self.value {
                ::std::option::Option::Some(dimension::Value::DimParam(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_dim_param(&mut self) -> ::std::string::String {
            if self.has_dim_param() {
                match self.value.take() {
                    ::std::option::Option::Some(dimension::Value::DimParam(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional string denotation = 3;

        pub fn denotation(&self) -> &str {
            match self.denotation.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_denotation(&mut self) {
            self.denotation = ::std::option::Option::None;
        }

        pub fn has_denotation(&self) -> bool {
            self.denotation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denotation(&mut self, v: ::std::string::String) {
            self.denotation = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_denotation(&mut self) -> &mut ::std::string::String {
            if self.denotation.is_none() {
                self.denotation = ::std::option::Option::Some(::std::string::String::new());
            }
            self.denotation.as_mut().unwrap()
        }

        // Take field
        pub fn take_denotation(&mut self) -> ::std::string::String {
            self.denotation.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::protobuf::Message for Dimension {
        const NAME: &'static str = "Dimension";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.value = ::std::option::Option::Some(dimension::Value::DimValue(is.read_int64()?));
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(dimension::Value::DimParam(is.read_string()?));
                    },
                    26 => {
                        self.denotation = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.denotation.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &dimension::Value::DimValue(v) => {
                        my_size += ::protobuf::rt::int64_size(1, v);
                    },
                    &dimension::Value::DimParam(ref v) => {
                        my_size += ::protobuf::rt::string_size(2, &v);
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.denotation.as_ref() {
                os.write_string(3, v)?;
            }
            if let ::std::option::Option::Some(ref v) = self.value {
                match v {
                    &dimension::Value::DimValue(v) => {
                        os.write_int64(1, v)?;
                    },
                    &dimension::Value::DimParam(ref v) => {
                        os.write_string(2, v)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Dimension {
            Dimension::new()
        }

        fn clear(&mut self) {
            self.value = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.denotation = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Dimension {
            static instance: Dimension = Dimension {
                denotation: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Dimension`
    pub mod dimension {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:onnx.TensorShapeProto.Dimension.value)
        pub enum Value {
            // @@protoc_insertion_point(oneof_field:onnx.TensorShapeProto.Dimension.dim_value)
            DimValue(i64),
            // @@protoc_insertion_point(oneof_field:onnx.TensorShapeProto.Dimension.dim_param)
            DimParam(::std::string::String),
        }

        impl ::protobuf::Oneof for Value {
        }

        impl Value {
        }
    }
}

///  Types
///
///  The standard ONNX data types.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.TypeProto)
pub struct TypeProto {
    // message fields
    ///  An optional denotation can be used to denote the whole
    ///  type with a standard semantic description as to what is
    ///  stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
    ///  for pre-defined type denotations.
    // @@protoc_insertion_point(field:onnx.TypeProto.denotation)
    pub denotation: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<type_proto::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.TypeProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeProto {
    fn default() -> &'a TypeProto {
        <TypeProto as ::protobuf::Message>::default_instance()
    }
}

impl TypeProto {
    pub fn new() -> TypeProto {
        ::std::default::Default::default()
    }

    // optional .onnx.TypeProto.Tensor tensor_type = 1;

    pub fn tensor_type(&self) -> &type_proto::Tensor {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::TensorType(ref v)) => v,
            _ => <type_proto::Tensor as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_tensor_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_tensor_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::TensorType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tensor_type(&mut self, v: type_proto::Tensor) {
        self.value = ::std::option::Option::Some(type_proto::Value::TensorType(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tensor_type(&mut self) -> &mut type_proto::Tensor {
        if let ::std::option::Option::Some(type_proto::Value::TensorType(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(type_proto::Value::TensorType(type_proto::Tensor::new()));
        }
        match self.value {
            ::std::option::Option::Some(type_proto::Value::TensorType(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tensor_type(&mut self) -> type_proto::Tensor {
        if self.has_tensor_type() {
            match self.value.take() {
                ::std::option::Option::Some(type_proto::Value::TensorType(v)) => v,
                _ => panic!(),
            }
        } else {
            type_proto::Tensor::new()
        }
    }

    // optional .onnx.TypeProto.Sequence sequence_type = 4;

    pub fn sequence_type(&self) -> &type_proto::Sequence {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::SequenceType(ref v)) => v,
            _ => <type_proto::Sequence as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sequence_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sequence_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::SequenceType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequence_type(&mut self, v: type_proto::Sequence) {
        self.value = ::std::option::Option::Some(type_proto::Value::SequenceType(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequence_type(&mut self) -> &mut type_proto::Sequence {
        if let ::std::option::Option::Some(type_proto::Value::SequenceType(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(type_proto::Value::SequenceType(type_proto::Sequence::new()));
        }
        match self.value {
            ::std::option::Option::Some(type_proto::Value::SequenceType(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequence_type(&mut self) -> type_proto::Sequence {
        if self.has_sequence_type() {
            match self.value.take() {
                ::std::option::Option::Some(type_proto::Value::SequenceType(v)) => v,
                _ => panic!(),
            }
        } else {
            type_proto::Sequence::new()
        }
    }

    // optional .onnx.TypeProto.Map map_type = 5;

    pub fn map_type(&self) -> &type_proto::Map {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::MapType(ref v)) => v,
            _ => <type_proto::Map as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_map_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_map_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::MapType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_type(&mut self, v: type_proto::Map) {
        self.value = ::std::option::Option::Some(type_proto::Value::MapType(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_type(&mut self) -> &mut type_proto::Map {
        if let ::std::option::Option::Some(type_proto::Value::MapType(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(type_proto::Value::MapType(type_proto::Map::new()));
        }
        match self.value {
            ::std::option::Option::Some(type_proto::Value::MapType(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_type(&mut self) -> type_proto::Map {
        if self.has_map_type() {
            match self.value.take() {
                ::std::option::Option::Some(type_proto::Value::MapType(v)) => v,
                _ => panic!(),
            }
        } else {
            type_proto::Map::new()
        }
    }

    // optional .onnx.TypeProto.Optional optional_type = 9;

    pub fn optional_type(&self) -> &type_proto::Optional {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::OptionalType(ref v)) => v,
            _ => <type_proto::Optional as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_optional_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_optional_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::OptionalType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_optional_type(&mut self, v: type_proto::Optional) {
        self.value = ::std::option::Option::Some(type_proto::Value::OptionalType(v))
    }

    // Mutable pointer to the field.
    pub fn mut_optional_type(&mut self) -> &mut type_proto::Optional {
        if let ::std::option::Option::Some(type_proto::Value::OptionalType(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(type_proto::Value::OptionalType(type_proto::Optional::new()));
        }
        match self.value {
            ::std::option::Option::Some(type_proto::Value::OptionalType(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_optional_type(&mut self) -> type_proto::Optional {
        if self.has_optional_type() {
            match self.value.take() {
                ::std::option::Option::Some(type_proto::Value::OptionalType(v)) => v,
                _ => panic!(),
            }
        } else {
            type_proto::Optional::new()
        }
    }

    // optional .onnx.TypeProto.SparseTensor sparse_tensor_type = 8;

    pub fn sparse_tensor_type(&self) -> &type_proto::SparseTensor {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::SparseTensorType(ref v)) => v,
            _ => <type_proto::SparseTensor as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sparse_tensor_type(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sparse_tensor_type(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(type_proto::Value::SparseTensorType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sparse_tensor_type(&mut self, v: type_proto::SparseTensor) {
        self.value = ::std::option::Option::Some(type_proto::Value::SparseTensorType(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sparse_tensor_type(&mut self) -> &mut type_proto::SparseTensor {
        if let ::std::option::Option::Some(type_proto::Value::SparseTensorType(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(type_proto::Value::SparseTensorType(type_proto::SparseTensor::new()));
        }
        match self.value {
            ::std::option::Option::Some(type_proto::Value::SparseTensorType(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sparse_tensor_type(&mut self) -> type_proto::SparseTensor {
        if self.has_sparse_tensor_type() {
            match self.value.take() {
                ::std::option::Option::Some(type_proto::Value::SparseTensorType(v)) => v,
                _ => panic!(),
            }
        } else {
            type_proto::SparseTensor::new()
        }
    }

    // optional string denotation = 6;

    pub fn denotation(&self) -> &str {
        match self.denotation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_denotation(&mut self) {
        self.denotation = ::std::option::Option::None;
    }

    pub fn has_denotation(&self) -> bool {
        self.denotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denotation(&mut self, v: ::std::string::String) {
        self.denotation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denotation(&mut self) -> &mut ::std::string::String {
        if self.denotation.is_none() {
            self.denotation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.denotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_denotation(&mut self) -> ::std::string::String {
        self.denotation.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TypeProto {
    const NAME: &'static str = "TypeProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(type_proto::Value::TensorType(is.read_message()?));
                },
                34 => {
                    self.value = ::std::option::Option::Some(type_proto::Value::SequenceType(is.read_message()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(type_proto::Value::MapType(is.read_message()?));
                },
                74 => {
                    self.value = ::std::option::Option::Some(type_proto::Value::OptionalType(is.read_message()?));
                },
                66 => {
                    self.value = ::std::option::Option::Some(type_proto::Value::SparseTensorType(is.read_message()?));
                },
                50 => {
                    self.denotation = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.denotation.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &type_proto::Value::TensorType(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_proto::Value::SequenceType(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_proto::Value::MapType(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_proto::Value::OptionalType(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &type_proto::Value::SparseTensorType(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.denotation.as_ref() {
            os.write_string(6, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &type_proto::Value::TensorType(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &type_proto::Value::SequenceType(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &type_proto::Value::MapType(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &type_proto::Value::OptionalType(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &type_proto::Value::SparseTensorType(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeProto {
        TypeProto::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.denotation = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeProto {
        static instance: TypeProto = TypeProto {
            denotation: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `TypeProto`
pub mod type_proto {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:onnx.TypeProto.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:onnx.TypeProto.tensor_type)
        TensorType(Tensor),
        // @@protoc_insertion_point(oneof_field:onnx.TypeProto.sequence_type)
        SequenceType(Sequence),
        // @@protoc_insertion_point(oneof_field:onnx.TypeProto.map_type)
        MapType(Map),
        // @@protoc_insertion_point(oneof_field:onnx.TypeProto.optional_type)
        OptionalType(Optional),
        // @@protoc_insertion_point(oneof_field:onnx.TypeProto.sparse_tensor_type)
        SparseTensorType(SparseTensor),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl Value {
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TypeProto.Tensor)
    pub struct Tensor {
        // message fields
        ///  This field MUST NOT have the value of UNDEFINED
        ///  This field MUST have a valid TensorProto.DataType value
        ///  This field MUST be present for this version of the IR.
        // @@protoc_insertion_point(field:onnx.TypeProto.Tensor.elem_type)
        pub elem_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:onnx.TypeProto.Tensor.shape)
        pub shape: ::protobuf::MessageField<super::TensorShapeProto>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TypeProto.Tensor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tensor {
        fn default() -> &'a Tensor {
            <Tensor as ::protobuf::Message>::default_instance()
        }
    }

    impl Tensor {
        pub fn new() -> Tensor {
            ::std::default::Default::default()
        }

        // optional int32 elem_type = 1;

        pub fn elem_type(&self) -> i32 {
            self.elem_type.unwrap_or(0)
        }

        pub fn clear_elem_type(&mut self) {
            self.elem_type = ::std::option::Option::None;
        }

        pub fn has_elem_type(&self) -> bool {
            self.elem_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_elem_type(&mut self, v: i32) {
            self.elem_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Tensor {
        const NAME: &'static str = "Tensor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.elem_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.elem_type {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.shape.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.elem_type {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.shape.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tensor {
            Tensor::new()
        }

        fn clear(&mut self) {
            self.elem_type = ::std::option::Option::None;
            self.shape.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tensor {
            static instance: Tensor = Tensor {
                elem_type: ::std::option::Option::None,
                shape: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    ///  repeated T
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TypeProto.Sequence)
    pub struct Sequence {
        // message fields
        ///  The type and optional shape of each element of the sequence.
        ///  This field MUST be present for this version of the IR.
        // @@protoc_insertion_point(field:onnx.TypeProto.Sequence.elem_type)
        pub elem_type: ::protobuf::MessageField<super::TypeProto>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TypeProto.Sequence.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sequence {
        fn default() -> &'a Sequence {
            <Sequence as ::protobuf::Message>::default_instance()
        }
    }

    impl Sequence {
        pub fn new() -> Sequence {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Sequence {
        const NAME: &'static str = "Sequence";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.elem_type)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.elem_type.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.elem_type.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sequence {
            Sequence::new()
        }

        fn clear(&mut self) {
            self.elem_type.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sequence {
            static instance: Sequence = Sequence {
                elem_type: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    ///  map<K,V>
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TypeProto.Map)
    pub struct Map {
        // message fields
        ///  This field MUST have a valid TensorProto.DataType value
        ///  This field MUST be present for this version of the IR.
        ///  This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
        // @@protoc_insertion_point(field:onnx.TypeProto.Map.key_type)
        pub key_type: ::std::option::Option<i32>,
        ///  This field MUST be present for this version of the IR.
        // @@protoc_insertion_point(field:onnx.TypeProto.Map.value_type)
        pub value_type: ::protobuf::MessageField<super::TypeProto>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TypeProto.Map.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Map {
        fn default() -> &'a Map {
            <Map as ::protobuf::Message>::default_instance()
        }
    }

    impl Map {
        pub fn new() -> Map {
            ::std::default::Default::default()
        }

        // optional int32 key_type = 1;

        pub fn key_type(&self) -> i32 {
            self.key_type.unwrap_or(0)
        }

        pub fn clear_key_type(&mut self) {
            self.key_type = ::std::option::Option::None;
        }

        pub fn has_key_type(&self) -> bool {
            self.key_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key_type(&mut self, v: i32) {
            self.key_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for Map {
        const NAME: &'static str = "Map";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.key_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.value_type)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.key_type {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value_type.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.key_type {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value_type.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Map {
            Map::new()
        }

        fn clear(&mut self) {
            self.key_type = ::std::option::Option::None;
            self.value_type.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Map {
            static instance: Map = Map {
                key_type: ::std::option::Option::None,
                value_type: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    ///  wrapper for Tensor, Sequence, or Map
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TypeProto.Optional)
    pub struct Optional {
        // message fields
        ///  The type and optional shape of the element wrapped.
        ///  This field MUST be present for this version of the IR.
        ///  Possible values correspond to OptionalProto.DataType enum
        // @@protoc_insertion_point(field:onnx.TypeProto.Optional.elem_type)
        pub elem_type: ::protobuf::MessageField<super::TypeProto>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TypeProto.Optional.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Optional {
        fn default() -> &'a Optional {
            <Optional as ::protobuf::Message>::default_instance()
        }
    }

    impl Optional {
        pub fn new() -> Optional {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Optional {
        const NAME: &'static str = "Optional";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.elem_type)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.elem_type.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.elem_type.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Optional {
            Optional::new()
        }

        fn clear(&mut self) {
            self.elem_type.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Optional {
            static instance: Optional = Optional {
                elem_type: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:onnx.TypeProto.SparseTensor)
    pub struct SparseTensor {
        // message fields
        ///  This field MUST NOT have the value of UNDEFINED
        ///  This field MUST have a valid TensorProto.DataType value
        ///  This field MUST be present for this version of the IR.
        // @@protoc_insertion_point(field:onnx.TypeProto.SparseTensor.elem_type)
        pub elem_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:onnx.TypeProto.SparseTensor.shape)
        pub shape: ::protobuf::MessageField<super::TensorShapeProto>,
        // special fields
        // @@protoc_insertion_point(special_field:onnx.TypeProto.SparseTensor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SparseTensor {
        fn default() -> &'a SparseTensor {
            <SparseTensor as ::protobuf::Message>::default_instance()
        }
    }

    impl SparseTensor {
        pub fn new() -> SparseTensor {
            ::std::default::Default::default()
        }

        // optional int32 elem_type = 1;

        pub fn elem_type(&self) -> i32 {
            self.elem_type.unwrap_or(0)
        }

        pub fn clear_elem_type(&mut self) {
            self.elem_type = ::std::option::Option::None;
        }

        pub fn has_elem_type(&self) -> bool {
            self.elem_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_elem_type(&mut self, v: i32) {
            self.elem_type = ::std::option::Option::Some(v);
        }
    }

    impl ::protobuf::Message for SparseTensor {
        const NAME: &'static str = "SparseTensor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.elem_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.shape)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.elem_type {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.shape.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.elem_type {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.shape.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SparseTensor {
            SparseTensor::new()
        }

        fn clear(&mut self) {
            self.elem_type = ::std::option::Option::None;
            self.shape.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SparseTensor {
            static instance: SparseTensor = SparseTensor {
                elem_type: ::std::option::Option::None,
                shape: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

///  Operator Sets
///
///  OperatorSets are uniquely identified by a (domain, opset_version) pair.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.OperatorSetIdProto)
pub struct OperatorSetIdProto {
    // message fields
    ///  The domain of the operator set being identified.
    ///  The empty string ("") or absence of this field implies the operator
    ///  set that is defined as part of the ONNX specification.
    ///  This field MUST be present in this version of the IR when referring to any other operator set.
    // @@protoc_insertion_point(field:onnx.OperatorSetIdProto.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    ///  The version of the operator set being identified.
    ///  This field MUST be present in this version of the IR.
    // @@protoc_insertion_point(field:onnx.OperatorSetIdProto.version)
    pub version: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.OperatorSetIdProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperatorSetIdProto {
    fn default() -> &'a OperatorSetIdProto {
        <OperatorSetIdProto as ::protobuf::Message>::default_instance()
    }
}

impl OperatorSetIdProto {
    pub fn new() -> OperatorSetIdProto {
        ::std::default::Default::default()
    }

    // optional string domain = 1;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 version = 2;

    pub fn version(&self) -> i64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OperatorSetIdProto {
    const NAME: &'static str = "OperatorSetIdProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.domain.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperatorSetIdProto {
        OperatorSetIdProto::new()
    }

    fn clear(&mut self) {
        self.domain = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperatorSetIdProto {
        static instance: OperatorSetIdProto = OperatorSetIdProto {
            domain: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:onnx.FunctionProto)
pub struct FunctionProto {
    // message fields
    ///  The name of the function, similar usage of op_type in OperatorProto.
    ///  Combined with FunctionProto.domain, this forms the unique identity of
    ///  the FunctionProto.
    // @@protoc_insertion_point(field:onnx.FunctionProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  The inputs and outputs of the function.
    // @@protoc_insertion_point(field:onnx.FunctionProto.input)
    pub input: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:onnx.FunctionProto.output)
    pub output: ::std::vec::Vec<::std::string::String>,
    ///  The attributes of the function.
    // @@protoc_insertion_point(field:onnx.FunctionProto.attribute)
    pub attribute: ::std::vec::Vec<::std::string::String>,
    ///  The nodes in the function.
    // @@protoc_insertion_point(field:onnx.FunctionProto.node)
    pub node: ::std::vec::Vec<NodeProto>,
    ///  A human-readable documentation for this function. Markdown is allowed.
    // @@protoc_insertion_point(field:onnx.FunctionProto.doc_string)
    pub doc_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:onnx.FunctionProto.opset_import)
    pub opset_import: ::std::vec::Vec<OperatorSetIdProto>,
    ///  The domain which this function belongs to. Combined with FunctionProto.name, this forms the unique identity of
    ///  the FunctionProto.
    // @@protoc_insertion_point(field:onnx.FunctionProto.domain)
    pub domain: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:onnx.FunctionProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FunctionProto {
    fn default() -> &'a FunctionProto {
        <FunctionProto as ::protobuf::Message>::default_instance()
    }
}

impl FunctionProto {
    pub fn new() -> FunctionProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string doc_string = 8;

    pub fn doc_string(&self) -> &str {
        match self.doc_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_doc_string(&mut self) {
        self.doc_string = ::std::option::Option::None;
    }

    pub fn has_doc_string(&self) -> bool {
        self.doc_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doc_string(&mut self, v: ::std::string::String) {
        self.doc_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc_string(&mut self) -> &mut ::std::string::String {
        if self.doc_string.is_none() {
            self.doc_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.doc_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_doc_string(&mut self) -> ::std::string::String {
        self.doc_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 10;

    pub fn domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_domain(&mut self) {
        self.domain = ::std::option::Option::None;
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain = ::std::option::Option::Some(::std::string::String::new());
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FunctionProto {
    const NAME: &'static str = "FunctionProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.input.push(is.read_string()?);
                },
                42 => {
                    self.output.push(is.read_string()?);
                },
                50 => {
                    self.attribute.push(is.read_string()?);
                },
                58 => {
                    self.node.push(is.read_message()?);
                },
                66 => {
                    self.doc_string = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.opset_import.push(is.read_message()?);
                },
                82 => {
                    self.domain = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.attribute {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.doc_string.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.opset_import {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.input {
            os.write_string(4, &v)?;
        };
        for v in &self.output {
            os.write_string(5, &v)?;
        };
        for v in &self.attribute {
            os.write_string(6, &v)?;
        };
        for v in &self.node {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.doc_string.as_ref() {
            os.write_string(8, v)?;
        }
        for v in &self.opset_import {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.domain.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FunctionProto {
        FunctionProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.input.clear();
        self.output.clear();
        self.attribute.clear();
        self.node.clear();
        self.doc_string = ::std::option::Option::None;
        self.opset_import.clear();
        self.domain = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FunctionProto {
        static instance: FunctionProto = FunctionProto {
            name: ::std::option::Option::None,
            input: ::std::vec::Vec::new(),
            output: ::std::vec::Vec::new(),
            attribute: ::std::vec::Vec::new(),
            node: ::std::vec::Vec::new(),
            doc_string: ::std::option::Option::None,
            opset_import: ::std::vec::Vec::new(),
            domain: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Versioning
///
///  ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
///
///  To be compatible with both proto2 and proto3, we will use a version number
///  that is not defined by the default value but an explicit enum number.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:onnx.Version)
pub enum Version {
    // @@protoc_insertion_point(enum_value:onnx.Version._START_VERSION)
    _START_VERSION = 0,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_10_10)
    IR_VERSION_2017_10_10 = 1,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_10_30)
    IR_VERSION_2017_10_30 = 2,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2017_11_3)
    IR_VERSION_2017_11_3 = 3,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2019_1_22)
    IR_VERSION_2019_1_22 = 4,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2019_3_18)
    IR_VERSION_2019_3_18 = 5,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2019_9_19)
    IR_VERSION_2019_9_19 = 6,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION_2020_5_8)
    IR_VERSION_2020_5_8 = 7,
    // @@protoc_insertion_point(enum_value:onnx.Version.IR_VERSION)
    IR_VERSION = 8,
}

impl ::protobuf::Enum for Version {
    const NAME: &'static str = "Version";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Version> {
        match value {
            0 => ::std::option::Option::Some(Version::_START_VERSION),
            1 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_10),
            2 => ::std::option::Option::Some(Version::IR_VERSION_2017_10_30),
            3 => ::std::option::Option::Some(Version::IR_VERSION_2017_11_3),
            4 => ::std::option::Option::Some(Version::IR_VERSION_2019_1_22),
            5 => ::std::option::Option::Some(Version::IR_VERSION_2019_3_18),
            6 => ::std::option::Option::Some(Version::IR_VERSION_2019_9_19),
            7 => ::std::option::Option::Some(Version::IR_VERSION_2020_5_8),
            8 => ::std::option::Option::Some(Version::IR_VERSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Version] = &[
        Version::_START_VERSION,
        Version::IR_VERSION_2017_10_10,
        Version::IR_VERSION_2017_10_30,
        Version::IR_VERSION_2017_11_3,
        Version::IR_VERSION_2019_1_22,
        Version::IR_VERSION_2019_3_18,
        Version::IR_VERSION_2019_9_19,
        Version::IR_VERSION_2020_5_8,
        Version::IR_VERSION,
    ];
}

impl ::std::default::Default for Version {
    fn default() -> Self {
        Version::_START_VERSION
    }
}


///  Operator/function status.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:onnx.OperatorStatus)
pub enum OperatorStatus {
    // @@protoc_insertion_point(enum_value:onnx.OperatorStatus.EXPERIMENTAL)
    EXPERIMENTAL = 0,
    // @@protoc_insertion_point(enum_value:onnx.OperatorStatus.STABLE)
    STABLE = 1,
}

impl ::protobuf::Enum for OperatorStatus {
    const NAME: &'static str = "OperatorStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperatorStatus> {
        match value {
            0 => ::std::option::Option::Some(OperatorStatus::EXPERIMENTAL),
            1 => ::std::option::Option::Some(OperatorStatus::STABLE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OperatorStatus] = &[
        OperatorStatus::EXPERIMENTAL,
        OperatorStatus::STABLE,
    ];
}

impl ::std::default::Default for OperatorStatus {
    fn default() -> Self {
        OperatorStatus::EXPERIMENTAL
    }
}

